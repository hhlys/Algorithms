# 2 算法导论 

## 2.1 插入排序
### 问题描述：
输入：n个数的一个序列（a1，a2，...，an）
输出：输入序列的一个排列（a1'，a2‘，...，an'）,满足a1'<=a2'<=...<=an’。

### 循环不变式
目的：理解算法的正确性
步骤：找到该算法的循环不变式，证明下面三条性质
1.**初始化** ： 循环的第一次迭代之前，它为真。
2.**保持** ： 如果循环的某次迭代之前它为真，则下次迭代之前它仍为真。
3.**终止** ：在循环终止时，验证算法是正确的。


### 伪代码

~~~
 for i = 2 to A.length
 	key = A[i]
 	//将A[i]插入到已排好序的A[1,...,j-1]中
 	j = i-1
 	while(j>0 and a[j]>key)
 		a[j+1] = a[j]
 		j = j-1
 	A[j+1] = key
~~~



以插入排序为例证明：

循环不变式：下标i指出了当前要插入到已排序列的数，在for循环每次迭代的开始，包含元素A[1,i-1]构成了已排序的序列，剩余的A[j+1,...,n]是未排序的序列。

证明如下：

1.初始化：第一次循环迭代之前，i为2，已排序序列由A[1]一个元素，成立。

2.保持：假设第当i = r(2<r<n)时循环不变式成立，此时A[1,...,r-1]为已排序，while循环将A[r]插入到A[1,r-1]的正确位置上，当i=r+1时，此时已排序序列为A[1,...,r]。

3.终止：终止条件是i>n,当执行最后一次迭代后，必有i= n+1;则A[1,...,n]已排序。因此算法正确。

### 课后题

2.1.1 略
2.1.2 描述：重写INSERTION-SORT，使之按升序排列。
	答：将伪代码第5行里的a[j]>a<key变成a[j]<key。	
2.1.3 描述：输入：n个数的序列，A= {a1,a2,...,an}和一个值v。
		输出：下标i使得v = A[i]或V不在A中时v为NIL。
		写出伪代码，用循环表达式证明你的算法的正确性。
伪代码：
~~~
	for(i = 1 to n)
		if(A[i]==v)
			return v;
		i++
	return v = NIL
~~~
证明：循环表达式：A[i]为当前待测试的值，A[1,...,i-1]里没有等于v的值。
初始化：i=1，当前一个也没有测试。
保持：当A[i]不等于v时，A[1,i]里没有等于v的值。
终止：当执行第i此迭代A[i]等于v,循环结束。当循环执行完毕，i = n+1,根据循环不变式，此时A[1,...,n]里没有等于v的值。返回v等于NIL。

2.1.4 
	输入：n元数组A，B存储着两个整数的二进制代码。
	输出：n+1元数组存储着两个整数的和的代码
伪代码：
~~~
	//设A[0]-->A[n]是高位到低位
	temp = 0
	for(i = 1 to n)
		sum = A[i]+B[i]+temp
		if(sum>=2)
			temp = 1
		else 
			temp = 0
	A[n+1] = temp
		
	
	
		