# 2 算法导论 

## 2.1 插入排序
### 问题描述：
输入：n个数的一个序列（a1，a2，...，an）
输出：输入序列的一个排列（a1'，a2‘，...，an'）,满足a1'<=a2'<=...<=an’。

### 循环不变式
目的：理解算法的正确性
步骤：找到该算法的循环不变式，证明下面三条性质
1.**初始化** ： 循环的第一次迭代之前，它为真。
2.**保持** ： 如果循环的某次迭代之前它为真，则下次迭代之前它仍为真。
3.**终止** ：在循环终止时，验证算法是正确的。


### 伪代码

~~~
 for i = 2 to n
 	key = A[i]
 	//将A[i]插入到已排好序的A[1,...,j-1]中
 	j = i-1
 	while(j>0 and a[j]>key)
 		a[j+1] = a[j]
 		j = j-1
 	A[j+1] = key
~~~



以插入排序为例证明：

循环不变式：下标i指出了当前要插入到已排序列的数，在for循环每次迭代的开始，包含元素A[1,i-1]构成了已排序的序列，剩余的A[j+1,...,n]是未排序的序列。

证明如下：

1.初始化：第一次循环迭代之前，i为2，已排序序列由A[1]一个元素，成立。

2.保持：假设第当i = r(2<r<n)时循环不变式成立，此时A[1,...,r-1]为已排序，while循环将A[r]插入到A[1,r-1]的正确位置上，当i=r+1时，此时已排序序列为A[1,...,r]。

3.终止：终止条件是i>n,当执行最后一次迭代后，必有i= n+1;则A[1,...,n]已排序。因此算法正确。

### 课后题

2.1.1 略 

2.1.2 描述：重写INSERTION-SORT，使之按升序排列。 

​	答：将伪代码第5行里的a[j]>a<key变成a[j]<key。  	
2.1.3 描述：输入：n个数的序列，A= {a1,a2,...,an}和一个值v。
​		输出：下标i使得v = A[i]或V不在A中时v为NIL。
​		写出伪代码，用循环表达式证明你的算法的正确性。
伪代码：

~~~
	for(i = 1 to n)
		if(A[i]==v)
			return v;
		i++
	return v = NIL
~~~
证明：循环表达式：A[i]为当前待测试的值，A[1,...,i-1]里没有等于v的值。
初始化：i=1，当前一个也没有测试。
保持：当A[i]不等于v时，A[1,i]里没有等于v的值。
终止：当执行第i此迭代A[i]等于v,循环结束。当循环执行完毕，i = n+1,根据循环不变式，此时A[1,...,n]里没有等于v的值。返回v等于NIL。

2.1.4  
	输入：n元数组A，B存储着两个整数的二进制代码。
	输出：n+1元数组存储着两个整数的和的代码
伪代码：

~~~
	//设A[0]-->A[n]是高位到低位
	temp = 0
	for(i = 1 to n)
		sum = A[i]+B[i]+temp
		if(sum>=2)
			temp = 1
		else 
			temp = 0
	A[n+1] = temp
	
~~~



## 2.2 分析算法

### RAM模型：

分析算法的模型，将算术指令，数据移动指令和控制指令都视为常量时间。 

### 插入排序算法的分析 
~~~										   
 for i = 2 to n                         
 	key = A[i]  								
 	//将A[i]插入到已排好序的A[1,...,j-1]中 		            
 	j = i-1										
 	while(j>0 and a[j]>key)						
 		a[j+1] = a[j]
 		j = j-1
 	A[j+1] = key
~~~

外层循环时间每一句执行次数为n,内层循环分别为为
$$
\sum_{n=1}^{100}{t_i} \ 和\sum_{n=1}^{100}{t_i-1}次。
$$

#### 最优情况
$$
分析最优情况为数组已排序序列，此时对于i从2到n,t_j则取值为1，则最大的运行时间项为
\sum_{n=2}^{n}{t_i}
= \ \Theta(n)
$$

#### 最坏情况
$$
分析最坏时间为数组逆序序列，此时对于i从2到n,t_j则取值为i，则最大的运行时间项为
\sum_{n=2}^{n}{t_i}
= \ \Theta(n^2)
$$

### 课后练习


#### 2.2.1 增长量级
$$
\frac{n^3}{1000-100n^2-100n+3} = \ \n^3
$$

#### 2.2.2 选择排序
~~~
 for(i = 1 to n-1)
 	temp = A[i];tempMin = A[i];tempIndex = i;
 	for(j = i+1 to n)
 		if(A[j]<tempMin)
 			tempMin = a[j]
 			tempIndex = j
 	A[i] = A[tempIndex]
 	A[tempIndex] = temp
~~~
循环不变式为循环的每次迭代开始前，A[1,...,i-1]已排好序。证明如下：
1.初始化：A[1,...,i-1]为空数组，正确。
2.保持：当i = r时，A[1,...,i-1]已排好序，执行此次迭代，内层for循环找到A[i,...,n]中的最小值，将最小值与A[i]交换位置。此次迭代结束，下次迭代开始前i = r+1;此时A[1,...,i]已排好序。正确。
3.终止：当i = n时终止，此时A[1,...,n-1]已排好序，因此A[1,...,n]已排好序。

算法分析：
$$
最好情况运行时间和最坏情况运行时间：\Theta(n^2)
$$

#### 2.2.3 平均需要查找数组一半的元素，最坏查找数组所有的元素。平均情况和怀情况运行时间都为
$$
\Theta(n)
$$

#### 2.2.4 

## 2.3 设计算法
### 2.3.1分治法
####分治法的三个步骤
1.分解原问题为若干子问题，这些子问题都是原问题规模较小的实例
2.解决这些子问题，递归的求解这些子问题，若子问题的规模足够小，直接求解。
3.合并这些子问题的解成原问题的解

#### 典型例子：归并排序
分解：分解待排序的n个元素的序列成n/2和n-n/2的两个子序列。
解决：使用归并排序递归的排序两个子序列
合并：合并两个已排序的子序列以产生已排序的答案

##### 伪代码

~~~
MERGE(A,p,q,r)
//A数组，p,q,r为下标，满足p<=q<r,该函数起始A[p,...,q]和A[q+1,r]都已是排好序的子序列。
countL = q-p+1
countR = r-q

for(i = 1 to q-p+1)
	AL[i] = A[i+p-1];
for(i = 1 to r-q)
	AR[i] = A[i+q]


~~~
